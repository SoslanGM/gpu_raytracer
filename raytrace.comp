#version 460

#define WIDTH 1280
#define HEIGHT 720


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
//layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (push_constant) uniform range
{
    int node_count;
};

// why is this ok without padding?
struct tree_entry
{
    int parent;
    int left;
    int right;
};
layout (std430, set = 0, binding = 0) coherent buffer _tree  { tree_entry tree[];  };
struct bvh_entry
{
    vec4 lower;
    vec4 upper;
};
layout (std430, set = 0, binding = 1) coherent buffer _bvh      { bvh_entry bvh[];      };
layout (std430, set = 0, binding = 2) coherent buffer _indexes  { uint      indexes[];  };
layout (std430, set = 0, binding = 3) coherent buffer _vertexes { float     vertexes[]; };
layout (set = 0, binding = 4, rgba8) uniform image2D im;


float t_min = 0.0001;
float t_max = 1000.0;
//float t_current = t_max;

vec4 sky_color    = vec4(1.0, 0.92, 0.77, 1.0);
vec4 monkey_color = vec4(0.2, 0.5,  1.0,  1.0);
vec4 light_color  = vec4(1.0, 1.0,  1.0,  1.0);

// ray v0: yes or no.
// ray v1: t.

// if the big box isn't hit, skip.
// otherwise keep checking for intersections.

struct ray
{
    vec3 o;
    vec3 d;
};

float RayBox(ray r, bvh_entry b)
{
    // two categories of hits: parallel and not.
    // second then subdivides into is it on the side of the box or somewhere in space.
    
    // test against all 6 planes, then pick the smallest across t_min < t < t_max.
    float x_min = b.lower[0];
    float x_max = b.upper[0];
    float y_min = b.lower[1];
    float y_max = b.upper[1];
    float z_min = b.lower[2];
    float z_max = b.upper[2];
    
    float t = t_max;
    
    // x
    {
        float inv_dir = 1.0 / r.d[0];
        
        float t0 = (x_min - r.o[0]) * inv_dir;
        float t1 = (x_max - r.o[0]) * inv_dir;
        
        float t_lesser = min(t0, t1);
        
        float py = r.o[1] + t_lesser * r.d[1];
        float pz = r.o[2] + t_lesser * r.d[2];
        
        // check bounds
        if((py == min(max(y_min, py), y_max)) &&
           (pz == min(max(z_min, pz), z_max)) )
        {
            if((t_min < t_lesser) && (t_lesser < t))
                t = t_lesser;
        }
    }
    
    // y
    {
        float inv_dir = 1.0 / r.d[1];
        
        float t0 = (y_min - r.o[1]) * inv_dir;
        float t1 = (y_max - r.o[1]) * inv_dir;
        
        float t_lesser = min(t0, t1);
        
        float px = r.o[0] + t_lesser * r.d[0];
        float pz = r.o[2] + t_lesser * r.d[2];
        
        // check bounds
        if((px == min(max(x_min, px), x_max)) &&
           (pz == min(max(z_min, pz), z_max)) )
        {
            if((t_min < t_lesser) && (t_lesser < t))
                t = t_lesser;
        }
    }
    
    // z
    {
        float inv_dir = 1.0 / r.d[2];
        
        float t0 = (z_min - r.o[2]) * inv_dir;
        float t1 = (z_max - r.o[2]) * inv_dir;
        
        float t_lesser = min(t0, t1);
        
        float px = r.o[0] + t_lesser * r.d[0];
        float py = r.o[1] + t_lesser * r.d[1];
        
        // check bounds
        if((px == min(max(x_min, px), x_max)) &&
           (py == min(max(y_min, py), y_max)) )
        {
            if((t_min < t_lesser) && (t_lesser < t))
                t = t_lesser;
        }
    }
    
    return t;
}





struct poly
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
    
    vec3 n0;
    vec3 n1;
    vec3 n2;
};

poly FetchTri(int index)
{
    poly p;
    
    uint i0 = indexes[3 * index];
    uint i1 = indexes[3 * index + 1];
    uint i2 = indexes[3 * index + 2];
    
    p.v0.x = vertexes[8 * i0];
    p.v0.y = vertexes[8 * i0 + 1];
    p.v0.z = vertexes[8 * i0 + 2];
    
    p.v1.x = vertexes[8 * i1];
    p.v1.y = vertexes[8 * i1 + 1];
    p.v1.z = vertexes[8 * i1 + 2];
    
    p.v2.x = vertexes[8 * i2];
    p.v2.y = vertexes[8 * i2 + 1];
    p.v2.z = vertexes[8 * i2 + 2];
    
    
    p.n0.x = vertexes[8 * i0 + 5];
    p.n0.y = vertexes[8 * i0 + 6];
    p.n0.z = vertexes[8 * i0 + 7];
    
    p.n1.x = vertexes[8 * i1 + 5];
    p.n1.y = vertexes[8 * i1 + 6];
    p.n1.z = vertexes[8 * i1 + 7];
    
    p.n2.x = vertexes[8 * i2 + 5];
    p.n2.y = vertexes[8 * i2 + 6];
    p.n2.z = vertexes[8 * i2 + 7];
    
    return p;
}



float cam_x = 0.0;
float cam_y = 0.0;
float cam_z = 25.0;


#define EXPERIMENT 1

int substack_size = 24;
int stack_counter = 0;
#if EXPERIMENT
shared int stack[8*8*24];  // group_width*group_height*substack
//shared int stack[32*32*16];  // group_width*group_height*substack
#elif !EXPERIMENT
int stack[24];
#endif

// what do you return?
struct hit_record
{
    float t;
    vec3 n;
};
hit_record RayTri(ray r, poly tri)
{
    hit_record rec;
    
    vec3 n_plane = normalize(cross(tri.v1-tri.v0, tri.v2-tri.v0));
    
    // if the ray is parallel to the triangle, we're not interested
    if(dot(r.d, n_plane) == 0)
    {
        rec.t = t_max;
        rec.n = n_plane;
        return rec;
    }
    
    
    
    // last component of the plane's equation:
    float d = -dot(n_plane, tri.v0);
    
    float t = - (dot(n_plane, r.o) + d) / dot(n_plane, r.d);
    
    
    // - Now let's see if the point belongs to the triangle.
    vec3 point = r.o + r.d * t;
    
    float rev_det_m = 1.0 / determinant(mat3(tri.v0, tri.v1, tri.v2));
    float det_a = determinant(mat3(point,  tri.v1, tri.v2));
    float det_b = determinant(mat3(tri.v0, point,  tri.v2));
    float det_c = determinant(mat3(tri.v0, tri.v1, point));
    
    float a = det_a * rev_det_m;
    float b = det_b * rev_det_m;
    float c = det_c * rev_det_m;
    
    vec3 n_point = (a * tri.n0 + b * tri.n1 + c * tri.n2) / (a+b+c);
    
    bool inside = true;
    if((a < 0) || (b < 0) || (c < 0))
        inside = false;
    
    rec.n = n_point;
    rec.t = (inside) ? t : t_max;
    
    return rec;
}

hit_record Trace(ray r, int node)
{
    while(node < node_count)
    {
        int left  = tree[node].left;
        int right = tree[node].right;
        
        float left_t  = RayBox(r, bvh[left]);
        float right_t = RayBox(r, bvh[right]);
        bool left_hit  = (left_t < t_max)  ? true : false;
        bool right_hit = (right_t < t_max) ? true : false;
        
        if(left_hit)
        {
            node = left;
            if(right_hit)
            {
#if EXPERIMENT
                stack[gl_LocalInvocationIndex*substack_size+stack_counter] = right;
                stack_counter++;
#elif !EXPERIMENT
                stack[stack_counter++] = right;
#endif
            }
        }
        else
        {
            if(right_hit)
                node = right;
            else
            {
                hit_record hit;
                hit.t = t_max;
                return hit;  // if you miss both children, time to go to next entry.
            }
        }
    }
    
    
    
    // - processing triangle now
    
    int obj_index_start_with_one = 1;
    int leaf_index = node - node_count + obj_index_start_with_one;
    
    poly tri = FetchTri(leaf_index);
    
    return RayTri(r, tri);
}



void main()
{
    if(gl_GlobalInvocationID.x > WIDTH || gl_GlobalInvocationID.y > HEIGHT)
        return;
    
    vec2 coord = gl_GlobalInvocationID.xy;
    
    // Map the image coords to the image plane; 1280,720 to 4,3- ratio's 16:9 though!
    // Top left corner + the thread coords.
    float x_initial = WIDTH;
    float x_final = 1.6f;
    float y_initial = HEIGHT;
    float y_final = 0.9f * (WIDTH / HEIGHT);
    
    float x_inc = x_final / x_initial;
    float y_inc = y_final / y_initial;
    
    float image_plane_z = -10.0;
    
    vec2 top_left;
    top_left.x = - x_final / 2.0;
    top_left.y = - y_final / 2.0;
    vec2 image_coord = vec2(top_left.x + x_inc * coord.x, top_left.y + y_inc * coord.y);
    
    ray r;
    r.o = vec3(cam_x, cam_y, cam_z);
    r.d = vec3(image_coord, image_plane_z);
    
    vec3 light_dir = normalize(vec3(cam_x, cam_y, cam_z));
    
    
    
    
    
    float t_current = t_max;
    vec3 normal;
    
    int root = 0;
    hit_record hit = Trace(r, root);
    if((t_min < hit.t) && (hit.t < t_current))
    {
        t_current = hit.t;
        normal    = hit.n;
    }
    while(stack_counter > 0)
    {
#if EXPERIMENT
        stack_counter--;
        hit_record hit = Trace(r, stack[gl_LocalInvocationIndex*substack_size+stack_counter]);
#elif !EXPERIMENT
        hit_record hit = Trace(r, stack[--stack_counter]);
#endif
        if((t_min < hit.t) && (hit.t < t_current))
        {
            t_current = hit.t;
            normal    = hit.n;
        }
    }
    
    
    
    
    
    vec4 color = sky_color;
    if(t_current < t_max)
    {
        float diffuse_coeff = max(dot(normal, light_dir), 0.1);
        vec3 diffuse = diffuse_coeff * light_color.rgb;
        
        color = vec4(monkey_color.rgb * diffuse, 1.0);
    }
    
    imageStore(im, ivec2(coord.x, HEIGHT-coord.y), color);
}