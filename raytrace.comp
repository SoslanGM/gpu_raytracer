#version 460

#define WIDTH 1280
#define HEIGHT 720

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;  // I wonder what's the difference gonna be with 32,1,1. 

layout (push_constant) uniform range
{
    int node_count;
};

// why is this ok without padding?
struct tree_entry
{
    int parent;
    int left;
    int right;
};
layout (std430, set = 0, binding = 0) coherent buffer _tree  { tree_entry tree[];  };
struct bvh_entry
{
    vec4 lower;
    vec4 upper;
};
layout (std430, set = 0, binding = 1) coherent buffer _bvh      { bvh_entry bvh[];      };
layout (std430, set = 0, binding = 2) coherent buffer _indexes  { uint      indexes[];  };
layout (std430, set = 0, binding = 3) coherent buffer _vertexes { float     vertexes[]; };
layout (set = 0, binding = 4, rgba8) uniform image2D im;


float t_min = 0.0001;
float t_max = 1000.0;
//float t_current = t_max;

vec4 sky_color    = vec4(1.0, 0.92, 0.77, 1.0);
vec4 monkey_color = vec4(0.2, 0.5,  1.0,  1.0);
vec4 light_color  = vec4(1.0, 1.0,  1.0,  1.0);

// ray v0: yes or no.
// ray v1: t.

// if the big box isn't hit, skip.
// otherwise keep checking for intersections.

struct ray
{
    vec3 o;
    vec3 d;
};

float RayBox(ray r, bvh_entry b)
{
    // two categories of hits: parallel and not.
    // second then subdivides into is it on the side of the box or somewhere in space.
    
    // test against all 6 planes, then pick the smallest across t_min < t < t_max.
    float x_min = b.lower.x;
    float x_max = b.upper.x;
    float y_min = b.lower.y;
    float y_max = b.upper.y;
    float z_min = b.lower.z;
    float z_max = b.upper.z;
    
    uint t_counter = 0;
    float t_values[6];
    
    float inv_dir_x = 1.0 / r.d.x;
    float inv_dir_y = 1.0 / r.d.y;
    float inv_dir_z = 1.0 / r.d.z;
    
    // x_min
    float t = (x_min - r.o.x) * inv_dir_x;
    if((t_min < t) && (t < t_max))
    {
        float py = r.o.y + t * r.d.y;
        float pz = r.o.z + t * r.d.z;
        
        // check bounds
        if((py == min(max(b.lower.y, py), b.upper.y)) &&
           (pz == min(max(b.lower.z, pz), b.upper.z)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    // x_max
    t = (x_max - r.o.x) * inv_dir_x;
    if((t_min < t) && (t < t_max))
    {
        float py = r.o.y + t * r.d.y;
        float pz = r.o.z + t * r.d.z;
        
        // check bounds
        if((py == min(max(b.lower.y, py), b.upper.y)) &&
           (pz == min(max(b.lower.z, pz), b.upper.z)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    
    // y_min
    t = (y_min - r.o.y) * inv_dir_y;
    if((t_min < t) && (t < t_max))
    {
        float px = r.o.x + t * r.d.x;
        float pz = r.o.z + t * r.d.z;
        
        // check bounds
        if((px == min(max(b.lower.x, px), b.upper.x)) &&
           (pz == min(max(b.lower.z, pz), b.upper.z)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    // y_max
    t = (y_max - r.o.y) * inv_dir_y;
    if((t_min < t) && (t < t_max))
    {
        float px = r.o.x + t * r.d.x;
        float pz = r.o.z + t * r.d.z;
        
        // check bounds
        if((px == min(max(b.lower.x, px), b.upper.x)) &&
           (pz == min(max(b.lower.z, pz), b.upper.z)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    
    // z_min
    t = (z_min - r.o.z) * inv_dir_z;
    if((t_min < t) && (t < t_max))
    {
        float px = r.o.x + t * r.d.x;
        float py = r.o.y + t * r.d.y;
        
        // check bounds
        if((px == min(max(b.lower.x, px), b.upper.x)) &&
           (py == min(max(b.lower.y, py), b.upper.y)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    // z_max
    t = (z_max - r.o.z) * inv_dir_z;
    if((t_min < t) && (t < t_max))
    {
        float px = r.o.x + t * r.d.x;
        float py = r.o.y + t * r.d.y;
        
        // check bounds
        if((px == min(max(b.lower.x, px), b.upper.x)) &&
           (py == min(max(b.lower.y, py), b.upper.y)) )
        {
            t_values[t_counter++] = t;
        }
    }
    
    // now look through the values and select the minimal
    
    if(t_counter > 0)
    {
        float minimal_t = min(min(min(t_values[0], t_values[1]), t_values[2]), min(min(t_values[3], t_values[4]), t_values[5]));
        return minimal_t;
    }
    else
        return t_max;
}


#define within(t) ((t_min < t) && (t < t_max))

struct poly
{
    vec3 v0;
    vec3 v1;
    vec3 v2;
    
    vec3 n0;
    vec3 n1;
    vec3 n2;
};

poly FetchTri(int index)
{
    poly p;
    
    uint i0 = indexes[3 * index];
    uint i1 = indexes[3 * index + 1];
    uint i2 = indexes[3 * index + 2];
    
    p.v0.x = vertexes[8 * i0];
    p.v0.y = vertexes[8 * i0 + 1];
    p.v0.z = vertexes[8 * i0 + 2];
    
    p.v1.x = vertexes[8 * i1];
    p.v1.y = vertexes[8 * i1 + 1];
    p.v1.z = vertexes[8 * i1 + 2];
    
    p.v2.x = vertexes[8 * i2];
    p.v2.y = vertexes[8 * i2 + 1];
    p.v2.z = vertexes[8 * i2 + 2];
    
    
    p.n0.x = vertexes[8 * i0 + 5];
    p.n0.y = vertexes[8 * i0 + 6];
    p.n0.z = vertexes[8 * i0 + 7];
    
    p.n1.x = vertexes[8 * i1 + 5];
    p.n1.y = vertexes[8 * i1 + 6];
    p.n1.z = vertexes[8 * i1 + 7];
    
    p.n2.x = vertexes[8 * i2 + 5];
    p.n2.y = vertexes[8 * i2 + 6];
    p.n2.z = vertexes[8 * i2 + 7];
    
    return p;
}



float cam_x = 0.0;
float cam_y = 0.0;
float cam_z = 25.0;


int stack_counter = 0;
int stack[100];

// what do you return?
struct tri_record
{
    float t;
    vec3 n;
};
tri_record RayTri(ray r, poly tri)
{
    tri_record rec;
    
    vec3 n_plane = normalize(cross(tri.v1-tri.v0, tri.v2-tri.v0));
    
    // if the ray is parallel to the triangle, we're not interested
    if(dot(r.d, n_plane) == 0)
    {
        rec.t = t_max;
        rec.n = n_plane;
        return rec;
    }
    
    
    
    // last component of the plane's equation:
    float d = -dot(n_plane, tri.v0);
    
    float t = - (dot(n_plane, r.o) + d) / dot(n_plane, r.d);
    
    
    // - Now let's see if the point belongs to the triangle.
    vec3 point = r.o + r.d * t;
    
    float det_m = determinant(mat3(tri.v0, tri.v1, tri.v2));
    float det_a = determinant(mat3(point,  tri.v1, tri.v2));
    float det_b = determinant(mat3(tri.v0, point,  tri.v2));
    float det_c = determinant(mat3(tri.v0, tri.v1, point));
    
    float a = det_a / det_m;
    float b = det_b / det_m;
    float c = det_c / det_m;
    
    vec3 n_point = (a * tri.n0 + b * tri.n1 + c * tri.n2) / (a+b+c);
    
    bool inside = true;
    if((a < 0) || (b < 0) || (c < 0))
        inside = false;
    
    rec.n = n_point;
    rec.t = (inside) ? t : t_max;
    
    return rec;
}

struct hit_record
{
    float t;
    vec4 color;
};
hit_record Trace(ray r, int node)
{
    while(node < node_count)
    {
        int left  = tree[node].left;
        int right = tree[node].right;
        
        float left_t  = RayBox(r, bvh[left]);
        float right_t = RayBox(r, bvh[right]);
        bool left_hit  = (left_t < t_max)  ? true : false;
        bool right_hit = (right_t < t_max) ? true : false;
        
        if(left_hit)
        {
            node = left;
            if(right_hit)
                stack[stack_counter++] = right;
        }
        else
        {
            if(right_hit)
                node = right;
            else
            {
                hit_record h;
                h.t = t_max;
                return h;  // if you miss both children, time to go to next entry.
            }
        }
    }
    
    
    
    // now we're dealing with a triangle
    int obj_vertex_index_offset = 1;
    int leaf_index = node - node_count + obj_vertex_index_offset;
    // for the first triangle, node == 15487, node_count == 15487...
    // ... so 0 is the correct index. 
    
    poly tri = FetchTri(leaf_index);
    tri_record rec = RayTri(r, tri);
    
    hit_record h;
    h.t = rec.t;
    if(rec.t < t_max)
    {
        vec3 light_dir = normalize(vec3(cam_x, cam_y, cam_z));
        
        float diffuse_coeff = max(dot(rec.n, light_dir), 0.1);
        vec3 diffuse = diffuse_coeff * light_color.rgb;
        
        h.color = vec4(monkey_color.rgb * diffuse, 1.0);
    }
    else;
    
    return h;
}



void main()
{
    if(gl_GlobalInvocationID.x > WIDTH || gl_GlobalInvocationID.y > HEIGHT)
        return;
    
    vec2 coord = gl_GlobalInvocationID.xy;
    
    // Map the image coords to the image plane; 1280,720 to 4,3- ratio's 16:9 though!
    // Top left corner + the thread coords.
    float x_initial = WIDTH;
    float x_final = 1.6f;
    float y_initial = HEIGHT;
    float y_final = 0.9f * (WIDTH / HEIGHT);
    
    float x_inc = x_final / x_initial;
    float y_inc = y_final / y_initial;
    
    float image_plane_z = -10.0;
    
    vec2 top_left;
    top_left.x = - x_final / 2.0;
    top_left.y = - y_final / 2.0;
    vec2 image_coord = vec2(top_left.x + x_inc * coord.x, top_left.y + y_inc * coord.y);
    
    ray r;
    r.o = vec3(cam_x, cam_y, cam_z);
    r.d = vec3(image_coord, image_plane_z);
    
    float t_current = t_max;
    vec4 color = sky_color;
    
    int root = 0;
    hit_record h = Trace(r, root);
    if(within(h.t) && (h.t < t_current))
    {
        t_current = h.t;
        color = h.color;
    }
    while(stack_counter > 0)
    {
        hit_record h = Trace(r, stack[--stack_counter]);
        if(within(h.t) && (h.t < t_current))
        {
            t_current = h.t;
            color = h.color;
        }
    }
    
    imageStore(im, ivec2(coord.x, HEIGHT-coord.y), color);
}